垃圾收集器基于分代收集算法 年轻代（1/3）+老年代(2/3)
年轻代=eden区（8/10）+from区（1/10）+to区（1/10）

minorGC:eden区放不下该对象时触发minorGC针对年轻代回收，一般采用复制算法把存活对象放进空的survivor区垃圾对象全部清理
每活过一次minorGC对象的分代年龄+1 当到达15岁时进入老年代(可以设置)

对象动态年龄判断机制:当非空survivor区的对象某一个年龄的对象的占比大于survivor区大小的50%,则把大于等于该年龄的所有对象全部放入老年代

fullGC:当老年代不能继续放入对象时触发fullGC对整个堆内存回收 采用标记整理或者标记清除算法

为了避免在触发minorGC时，复制对象带来的开销直接把大对象放入老年代(可以通过参数设置)

老年代分配担保机制:在每次触发minorGC前，jvm会判断当前老年代剩余空间（oldRemain）是否大于当前年轻代所有对象的大小，如果大于直接minorGC
否则判断是否设置了-XX:-HandlePromotionFailure，如果设置了该参数，会判断当前年轻代存活对象的大小是否大于历史每一次进入老年代的对象大小
如果大于，先进行一次fullGC再进行minorGC，如果小于直接minorGC，如果没有设置参数也直接minorGC。

serial收集器:串行单线程收集器 配合serial-old收集器使用 年轻代采用复制算法 老年代采用标记-整理算法
parallel收集器:serial收集器的多线程版本 不可以配合CMS收集器使用 jdk8默认使用该收集器 配合parallel-old使用 年轻代采用复制算法 老年代采用标记-整理算法
parNew收集器:和parallel收集器一样 优点在于可以和CMS收集器使用 parNew+CMS 年轻代采用复制算法 老年代采用标记-整理算法

CMS收集器:第一款并发收集器 针对老年代的回收 一般是parNew+CMS
CMS.1:初始标记 STW 标记gcRoots直接引用的对象 速度很快
CMS.2:并发标记 这个过程不STW。遍历从gcRoots出发的对象图 过程耗时长 但是不STW 但是容易出现浮动垃圾和漏标对象
CMS.3:重新标记 就是为了修正CMS.2期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录(主要是处理漏标问题)，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
CMS.4:并发清理 开启用户线程，同时GC线程开始对未标记的区域做清扫
CMS.5:并发重置 重置本次GC过程中的标记数据。

CMS优缺点:
优点:并发收集 低停顿 用户体验好
缺点:和业务线程争抢cpu资源;产生浮动垃圾和空间碎片（采用标记-清除算法）,-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理;
执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，

三色标记:
黑色 表示对象已经被垃圾收集器访问过,且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
灰色 表示对象已经被垃圾收集器访问过,但这个对象上至少存在一个引用还没有被扫描过。
白色 表示对象尚未被垃圾收集器访问过,显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。

漏标-读写屏障
漏标会导致被引用的对象被当成垃圾误删除，有两种解决方案：
增量更新（Incremental Update）
增量更新就是当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。
和原始快照（Snapshot At The Beginning，SATB） 。
原始快照就是当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)
以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。